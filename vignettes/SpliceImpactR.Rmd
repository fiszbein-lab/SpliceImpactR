---
title: "SpliceImpactR"
author:
- name: Zachary Wakefield
  affiliation:
  - &1 Boston University, Boston, MA
  - &2 Bioinformatics Program, Boston University, Boston, MA
- name: Ana Fiszbein
  affiliation:
  - *1
  - *2
date: '`r format(Sys.Date(), "%B %e, %Y")`'
package: SpliceImpactR
output:
    BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{SpliceImpactR}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::rmarkdown}
editor_options:
    chunk_output_type: console
---

```{r, include=FALSE, messages=FALSE, warnings=FALSE}
knitr::opts_chunk$set(comment="", fig.align="center", fig.width=8.75, cache=FALSE)
library(devtools)
library(tidyverse)
library(data.table)
library(dplyr)
library(SpliceImpactR)
```



# Introduction
An R package to identify functional impacts due to alternative RNA 
processing events

# Requirements

We recommend the latest version of R (\>= 4.0.0)

# Installation

Install the development version of the package from Github.

```{r}
devtools::install_github("fiszbein-lab/SpliceImpactR")
```

Or install the development version of the package from Bioconductor.

```{r}
BiocManager::install("fiszbein-lab/SpliceImpactR", version="devel")
```


# Usage
## Access gencode information
__SpliceImpactR__ requires the acceession of various genome annotations, accessed through biomaRt and directly through gencode, here we access the gencode files
```{r}
## Loading annotations (if they aren't previously cached takes a bit of time)
## We will initally load a test set
annotation_df <- get_annotation(load = "test")

## If we were looking to load the full annotations, we'd run the following (or load from paths of already downloaded gtf/fa files)
# annotation_df <- get_annotation(load = "link", species = 'human', version = 45, base_dir = "/.")

## After the initial lengthy loading of annotations, we could quickly load from cached rds files
# annotation_df <- get_annotation(load="cached", base_dir="/.")
```

## Access biomaRt information
Here we obtain further annotations through biomaRt
```{r}
## We're loading test data here, but set test = FALSE to get the full set
interpro_features <- get_protein_features(c("interpro"), annotation_df$annotations, timeout = 600, test = TRUE)
signalp_features <- get_protein_features(c("signalp"), annotation_df$annotations, timeout = 600, test = TRUE)


## When loading multiple features from biomaRt, we suggest loading in separate get_protein_features calls for each individual feature database
# interpro_features <- get_protein_features(c("signalp"), annotation_df$annotations, timeout = 600)
# interpro_features <- get_protein_features(c("interpro"), annotation_df$annotations, timeout = 600)

## We can also load user-defined protein features by transcript/protein ensembl ids and the location of the protein feature within the protein
# user_df <- data.table(
#  ensembl_transcript_id = c(
#    "ENST00000511072","ENST00000374900","ENST00000373020","ENST00000456328",
#    "ENST00000367770","ENST00000331789","ENST00000335137","ENST00000361567",
#    NA,                    "ENST00000380152"
#  ),
#  ensembl_peptide_id = c(
#    "ENSP00000426975", NA,                   "ENSP00000362048","ENSP00000407743",
#    "ENSP00000356802","ENSP00000326734", NA,                  "ENSP00000354587",
#    "ENSP00000364035", NA
#  ),
#  name = c(
#    "Low complexity","Transmembrane helix","Coiled-coil","Signal peptide",
#    "Transmembrane helix","Low complexity","Coiled-coil","Transmembrane helix",
#    "Signal peptide","Low complexity"
#  ),
#  start = c(80L, 201L, 35L, 1L, 410L, 150L, 220L, 30L, 1L, 300L),
#  stop  = c(120L,223L, 80L, 20L, 430L, 190L, 260L, 55L, 24L, 360L),
#  database   = c("seg","tmhmm","ncoils","signalp","tmhmm","seg","ncoils","tmhmm","signalp", NA),
#  alt_name   = c(NA,"TMhelix",NA,"SignalP-noTM", "TMhelix", NA, NA, "TMhelix", "SignalP-TAT", NA),
#  feature_id = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA)
# )
# user_features <- get_manual_features(user_df)

## We use this function to combine multiple protein features and the user-defined features
protein_feature_total <- get_comprehensive_annotations(list(signalp_features, interpro_features))


## Finally, we get the exon-level protein features from the prior overall features
exon_features <- get_exon_features(annotation_df$annotations, protein_feature_total)

```

## Loading data (rmats + hit index example)
For the sake of this intro, we use toy versions (limited to a handful of genes)
The sample data frame must have a path column pointing to where the files (rMATS output and hit_index is contained). We must also have sample_name and condition columns
```{r}
# For purposes of these examples, data directory is in extdata to point to toy data, however this should be replaced with the directory path to  data

# For the standard workflow, we require all output files within the same directory for each sample. rMATS analysis will look for the {AS}.MATS.JC/JCEC.txt and HIT Index will look for the .AFEPSI, .ALEPSI, and .exon files
# The data files should be organized as such for each sample:
print(list.files(check_extdata_dir('rawData/control_S5/')))

# If the rmats and hit index output are in separate directories, you can use get_hitindex() and get_rmats() to avoid reorganizing data files
sample_frame <- data.frame(path = c(check_extdata_dir('rawData/control_S5/'),
                                    check_extdata_dir('rawData/control_S6/'),
                                    check_extdata_dir('rawData/control_S7/'),
                                    check_extdata_dir('rawData/control_S8/'),
                                    check_extdata_dir('rawData/case_S1/'),
                                    check_extdata_dir('rawData/case_S2/'),
                                    check_extdata_dir('rawData/case_S3/'),
                                    check_extdata_dir('rawData/case_S4/')),
                           sample_name  = c("S5", "S6", "S7", "S8", "S1", "S2", "S3", "S4"),
                           condition    = c("control", "control", "control", "control", "case",  "case",  "case",  "case"),
                           stringsAsFactors = FALSE)
# Here we load both rmats and hit index data
data <- get_rmats_hit(sample_frame, event_types = c("ALE", "AFE", "MXE", "SE", "A3SS", "A5SS", "RI"))

## We can compare the HIT Index values across condition, to identify how classification/use of exons may change
hit_compare <- compare_hit_index(sample_frame, condition_map = c(control = "control", test = "case"))

## We can plot an overview of how the conditions compare as well. Here, we probe whether there are changes in depth-normalized counts of AFE or the distribution of PSI across condition
ov <- overview_splicing_comparison_fixed(hit_index, 
                                         sample_frame, 
                                         depth_norm = 'exon_files', 
                                         event_type = "AFE")


```


## Differential Inclusion
First we perform differential inclusion analysis. This uses a quasibinomial glm and subsequent F test to identify significant changes in PSI across condition. The default here is 10 minimum read count, at least present (nonzero) in half of the samples within either of the conditions. This step does various filtering and with verbose = TRUE prints out how many events are filtered / kept.

We filter for fdr < 0.05 and delta_psi > 0.1 and output a volcano plot
```{r}
res <- get_differential_inclusion(data, min_total_reads = 10)
res_di <- keep_sig_pairs(res)
volcano_plot <- plot_di_volcano_dt(res)
```

## Matching and pairing
Then we match the signficant output to annotation. Here, we attach associated transcript and protein sequences and then extract pairs of 'swapping' events.
```{r}
matched <- get_matched_events_chunked(res_di, annotation_df$annotations, chunk_size = 2000)
hits_sequences <- attach_sequences(matched, annotation_df$sequences)
pairs <- get_pairs(hits_sequences, source="multi")

## We can also perform analysis looking at how events impact protein length and 
## proximal/distal use of terminal exons
proximal_output <- get_proximal_shift_from_hits(pairs)
length_output <- plot_length_comparison(seq_compare)
```

## Primary sequence comparisons
Here, we compare sequence using protein-coding status, sequence alignment percent identity, protein length, and whether frame shifts / rescues are produced.
And make a summary plot
```{r}
seq_compare <-compare_sequence_frame(pairs, annotation_df$annotations)
alignment_summary <- plot_alignment_summary(seq_compare)

```

## Get background
We next must get a background set for domain enrichment analysis. We can do this through all annotated transcripts, a given set of possible transcripts, or the hit-index's .exon files
```{r}
bg <- get_background(source = "annotated",
                     annotations = annotation_df$annotations,
                     protein_features = protein_feature_total)
```

## Get domain changes
Here we identify when the alternative RNA processing event drives a change in protein features, then identify enriched domains using the backgrond set
```{r}
## First get the domains that change across pairs
hits_domain <- get_domains(seq_compare, exon_features)

## Then we can probe for any enriched domains that are changing and plot
enriched_domains <- enrich_domains_hypergeo(hits_domain, bg, db_filter = 'interpro')
domain_plot <- plot_enriched_domains_counts(enriched_domains, top_n = 20)

## And we're able to search for A) specific events enrichment (AFE, ALE, etc)
## or by database (Interpro, SignalP, etc)
enriched_domains <- enrich_by_event(hits_domain, bg, events = 'AFE', db_filter = 'interpro')
enriched_domains <- enrich_by_db(hits_domain, bg, dbs = 'interpro')

```

## Isoform-Isoform interaction network
For PPI analysis, we first obtain protein-protein interaction domain miner domain-domain interactions (ppidm)
And use those ddis to predict ppis 
```{r}
## First we load from ppidm
ppidm <- get_ppidm(test=TRUE)

## Then we identify the predicted ppi
ppi <- get_isoform_interactions(protein_feature_total, ppidm, save = FALSE, load_dir = NULL, init = TRUE)

## Now we can identify ppi switches and plot
hits_final <- get_ppi_switches(hits_domain, ppi)
ppi_plot <- plot_ppi_summary(hits_final)

```


## Integrative Analysis
Here we identify some holistic patterns / integrative analysis using all event types
```{r}
int_summary <- integrated_event_summary(hits_final, res)
```

```{r}
sessionInfo()
```

